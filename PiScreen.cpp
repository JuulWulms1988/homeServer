#include "PiScreen.h"

piScreenCls& piScreenC = *new piScreenCls;

void piScreenCls::start() {
	mpCh = &threadCls->strCntS[LEDPL_CNT + 1].open(100, LEDPL_CNT + 1, 32);
	lsNoPlay = mpCh->get(lsPlay);
	char buuuf[512]; memFileObj fileObj(fileData);
	{
		fileObj.open("Overige/piScreen.txt"); clientCnt = 0; while (!strbasprc::vergCharP(strbasprc::charPLsR(buuuf, fileObj.file, fileObj.loc), "AA")) clientCnt++; fileObj.loc = 0;
		screenObj = new screenObjS[clientCnt + 1]; for (uint8_t t = 0; t <= clientCnt; t++) screenObj[t].sBuf = new char[([&] { if (!t) return 519; return 15; })()];
		uint8_t t = 0; while (!strbasprc::vergCharP(strbasprc::charPLsR(buuuf, fileObj.file, fileObj.loc), "AA")) screenObj[++t].set(buuuf, strbasprc::charPLen(buuuf));
	}
	screenObj[0].adr = (strbasprc::charPLsR(buuuf, fileObj.file, fileObj.loc)[0] - '0') * 10 + (buuuf[1] - '0');
	{
		int uitpr;
		for (uint8_t t = 1; *strbasprc::charPLsR(buuuf, fileObj.file, fileObj.loc) && t <= clientCnt; t++)
			if (threadCls->statVar[uitpr = (*buuuf - '0') * 100 + (buuuf[1] - '0') * 10 + (buuuf[2] - '0') - 100].load()) pass(t + 512);
	}
	if (play) pass(512);
	for (uint8_t t = 0; t <= clientCnt; t++) screenObj[t].sendMpCh.ad = screenObj[t].adr;
	chanPoint = fileObj.file + fileObj.loc;
	for (unsigned long t = 0, l = 0; *strbasprc::charPLsR(buuuf, chanPoint, l) || ((t /= 2) && !(chanCnt = t)); t++);
}

void piScreenCls::chanF(uint16_t no, uint8_t ad) {
	bool Niet = true;
	{
		lock_guard<mutex> lk(sourceWmut[ad]); lock_guard<shared_mutex> lk2(sourceMut);
		if (chanBl)
			if (no == channel && play) return;
			else if (no > 255)
				if (!play) channel = 0;
				else if (no == 256)
					if (!channel) channel = chanCnt - 1;
					else channel--;
				else channel = (channel + 1) % chanCnt;
			else channel = no;
		else if ((chanBl = true) && (no < 256 || (channel = 0))) channel = no;
		unsigned long h = 0;
		sourceLen = strbasprc::charPLen(strbasprc::charPLsDR(channel * 2, source, chanPoint, h));
		if (!play) playPrep(2 + (play = !(Niet = false)) * 1, ad), passPrep(512, passPrMpCha[101], 101);
	} if (Niet) passPrep(0, passPrMpCha[ad], ad);
}

bool piScreenCls::StreamVidVar(char* x) {
	shared_lock<shared_mutex> lk(piScreenC.sourceMut);
	if ((!piScreenC.play && (x[0] = x[1] = '0')) || (chanBl && (x[0] = strbasprc::cvintcharchar((channel + 1) / 60)) && (x[1] = strbasprc::cvintcharchar((channel + 1) % 60)))) return false;
	strncpy_s(x, sourceLen - 1, source, sourceLen - 2); return true;
}

void piScreenCls::func(uint16_t s) {
	uint16_t yoyo;
	switch (s / 256) {
	case 0: connectF(s % 256); break;
	case 3: statMut.lock_shared(), yoyo = statCnt, statMut.unlock_shared(), serverIO(yoyo); break;
	default: statF((s / 256) - 1, s % 256); break;
	}
}

void ServerTelnet::accept_piScreen(unsigned int clNo, SOCKET clSock) {
	if (clNo > piScreenC.clientCnt) { _SOCK_CLOSE_F(clSock); return; } 
	{
		piScreenCls::screenObjS& p = piScreenC.screenObj[clNo];
		p.sockConMut.lock();
		if (p.connected && p.sock != clSock) _SOCK_CLOSE_F(p.sock);
		p.connected = true, p.sock = clSock; p.sockConMut.unlock();
	}
	piScreenC.pass(clNo);
	for (char t = 1, w; (_SOCK_RESULT_COMP(NetworkServices::receiveMessage(clSock, &w, 1)) && t < 16) || (t < 16 && !(t = 0)); t++);
	piScreenCls::screenObjS& p = piScreenC.screenObj[clNo];
	p.sockConMut.lock();
	if (p.connected && p.sock == clSock) _SOCK_CLOSE_F(clSock), p.connected = false;
	p.sockConMut.unlock();
}

void piScreenCls::pass(uint16_t s) {
	if (!passMpCha.begin(s)) return;
	threadBufCls::recStruct{ telnetS.tMut, [](void* pMCh, void* p) {
		do ((piScreenCls*)p)->func(((mainThreadCls::strMpCha*)pMCh)->p); while (!((mainThreadCls::strMpCha*)pMCh)->end());
	} }.start(&passMpCha, this);
}



void piScreenCls::passPrep(uint16_t s, mainThreadCls::strMpCha& mapCh, uint8_t ad) {
	if (!mapCh.begin(s)) return;
	mutex* P; if (ad == 100) P = &telnetS.tMut; else if (ad == 101) P = &threadMut; else P = threadCls->threadMut + ad;
	threadBufCls::recStruct{ *P, [](void* pMCh, void* p) {
		do ((piScreenCls*)p)->pass(((mainThreadCls::strMpCha*)pMCh)->p); while (!((mainThreadCls::strMpCha*)pMCh)->end());
	} }.start(&mapCh, this);
}

void mainThreadCls::sluisPiScreenF(uint16_t s, uint8_t ad) {
	piScreenC.passPrep(s, piScreenC.passPrMpCha[ad], ad);
}

void mainThreadCls::clsExMes::strExec::sluisPiScreenFC() {
	uint8_t aDD = point->pLisHome->adrs.load();
	piScreenC.chanF(strbasprc::cvintcharint(buf[2]) * 60 + strbasprc::cvintcharint(buf[3]), aDD);
}

void extCls::piSWrite(uint8_t i, char* x) {
	switch (i) {
	case 0: piScreenC.channel = strbasprc::cvintcharint(*x) * 60 + strbasprc::cvintcharint(x[1]); return;
	case 1: if (*x - '0') piScreenC.chanBl = true; else piScreenC.chanBl = false; return;
	case 2: piScreenC.sourceLen = strbasprc::cvintcharint(*x) * 60 + strbasprc::cvintcharint(x[1]); return;
	case 3: { char* p = piScreenC.source; while (*(p++) = *(x++)); return; }
	}
}

void* extCls::piSRead(uint8_t i) {
	switch (i) {
	case 0: piScreenC.sourceMut.lock_shared(); return (void*)(uint64_t)piScreenC.channel;
	case 1: if (piScreenC.chanBl) return (void*)(true); return NULL;
	case 2: return (void*)(uint64_t)piScreenC.sourceLen;
	case 3: return piScreenC.source;
	case 4: piScreenC.sourceMut.unlock_shared(); return NULL;
	default: return NULL;
	}
}

bool extCls::piSPlay(int8_t x) {
	if (x) { piScreenC.play = (bool)(x -= 1); return x; }
	shared_lock<shared_mutex> lk(piScreenC.sourceMut); return piScreenC.play;
}